---
key: 3. Dubbo集群
tags: JAVA Dubbo
show_edit_on_github: false
modify_date: 2019-09-15
---

## 一、概述

> 所谓集群（Cluster），通过聚焦多台较低配置的机器，可以实现在性能、可靠性、灵活性方面相对较高的收益，其任务调度是集群系统中的核心技术。

在Dubbo集群的技术，可以分为三个部分，目录（Directory）、负载均衡（Load Balance）与容错（Fault-Tolerant）。

目录（Directory)，Directory 代表多个 Invoker，可以把它看成 `List<Invoker> `，但与 List 不同的是，它的值可能是动态变化的，比如注册中心推送变更。

负载均衡（Load Balance），其意思就是分摊到多个操作单元上进行执行，从而共同完成工作任务。

容错（Fault-Tolerant），是指当系统在运行时有错误被激活的情况下仍能保证不间断提供服务的方法和技术。

## 二、目录（Directory)

![Directory结构](/assets/images/Directory结构.png)
由Directory接口的结构图可以看出，有两个具体的实现类，分别是`StaticDirectory`与`RegistryDirectory`， 这两个类共同继承了一个抽象类`AbstractDirectory`，下面对这三个类的内容进行详细解读。

### 1. Directory

```java
public interface Directory<T> extends Node {

    /**
     * get service type.
     *
     * @return service type.
     */
    Class<T> getInterface();

    /**
     * list invokers.
     *
     * @return invokers
     */
    List<Invoker<T>> list(Invocation invocation) throws RpcException;

}
```

接口只有两个功能，其一返回目录Dubbo服务接口的类，其二返回可用的`List<Invoker>`。

### 2. AbstractDirectory

```java
public abstract class AbstractDirectory<T> implements Directory<T> {
    
  	private final URL url;
		//维护目录的可用性标记
    private volatile boolean destroyed = false;
		
    private volatile URL consumerUrl;
		//路由链
    protected RouterChain<T> routerChain;

  
}
```

### 3. StaticDirectory

```java
public class StaticDirectory<T> extends AbstractDirectory<T> {
  //..omitted
  
  @Override
    protected List<Invoker<T>> doList(Invocation invocation) throws RpcException {
      	//1. 直接返回构造参数里的invokers
        List<Invoker<T>> finalInvokers = invokers;
        if (routerChain != null) {
            try {
              //2. 如果路由链不为空，则返回路由后的invokers
                finalInvokers = routerChain.route(getConsumerUrl(), invocation);
            } catch (Throwable t) {
                logger.error("Failed to execute router: " + getUrl() + ", cause: " + t.getMessage(), t);
            }
        }
        return finalInvokers == null ? Collections.emptyList() : finalInvokers;
    }
}
```



### 4. RegistryDirectory

这里的ResgistryDirectory对应一个注册中心上的目录。调用逻辑图如下：

![RegistryDirectory调用关系图](/assets/images/RegistryDirectory调用关系图.png)

```java
//1. 实现notifyListener,可以监听注册中心的变化
public class RegistryDirectory<T> extends AbstractDirectory<T> implements NotifyListener {
  		//..omitted
  
  
  		//2. 构造参数传入服务的类serviceType, 注册中心的url
      public RegistryDirectory(Class<T> serviceType, URL url) {
        super(url);
        if (serviceType == null) {
            throw new IllegalArgumentException("service type is null.");
        }
        if (url.getServiceKey() == null || url.getServiceKey().length() == 0) {
            throw new IllegalArgumentException("registry serviceKey is null.");
        }
        this.serviceType = serviceType;
        this.serviceKey = url.getServiceKey();
        //3. 读取注册中心url上的参数，这些参数是通过&连接，key=value这样的参数
        this.queryMap = StringUtils.parseQueryString(url.getParameterAndDecoded(REFER_KEY));
        //4. 将注册中心url转化为消费者url, 并赋值给overrideDirectoryUrl以及directoryUrl
        this.overrideDirectoryUrl = this.directoryUrl = turnRegistryUrlToConsumerUrl(url);
        //5. 读取组名，默认没有组
        String group = directoryUrl.getParameter(GROUP_KEY, "");
        //6. 判断是否有多个组
        this.multiGroup = group != null && (ANY_VALUE.equals(group) || group.contains(","));
    }
}
```



当监听到注册中心上的目录发生变化后，监听器会接收到一个`List<URL>`。

```java
    @Override
    public synchronized void notify(List<URL> urls) {
        Map<String, List<URL>> categoryUrls = urls.stream()
          //7. 过滤空的URL
                .filter(Objects::nonNull)
          //8. 过滤无效的Category
                .filter(this::isValidCategory)
          //9. 过滤compatible_config有值的url
                .filter(this::isNotCompatibleFor26x)
         //10. 根据url的类型，进行分组，主要有三种类型。配置URL， 路由URL，提供者URL
                .collect(Collectors.groupingBy(url -> {
                    if (UrlUtils.isConfigurator(url)) {
                        return CONFIGURATORS_CATEGORY;
                    } else if (UrlUtils.isRoute(url)) {
                        return ROUTERS_CATEGORY;
                    } else if (UrlUtils.isProvider(url)) {
                        return PROVIDERS_CATEGORY;
                    }
                    return "";
                }));

        List<URL> configuratorURLs = categoryUrls.getOrDefault(CONFIGURATORS_CATEGORY, Collections.emptyList());
        this.configurators = Configurator.toConfigurators(configuratorURLs).orElse(this.configurators);

        List<URL> routerURLs = categoryUrls.getOrDefault(ROUTERS_CATEGORY, Collections.emptyList());
        toRouters(routerURLs).ifPresent(this::addRouters);

        // providers
      //11. 从过滤的结果中，取出提供者URL。
        List<URL> providerURLs = categoryUrls.getOrDefault(PROVIDERS_CATEGORY, Collections.emptyList());
      //12. 覆盖刷新提供者的invokerList
        refreshOverrideAndInvoker(providerURLs);
    }

```



```java
    private void refreshOverrideAndInvoker(List<URL> urls) {
        // mock zookeeper://xxx?mock=return null
      //13. 覆盖更新目录的URL
        overrideDirectoryUrl();
      //14. 刷新invokerList
        refreshInvoker(urls);
    }

```



```java
    private void overrideDirectoryUrl() {
        // merge override parameters
        this.overrideDirectoryUrl = directoryUrl;
        List<Configurator> localConfigurators = this.configurators; // local reference
        doOverrideUrl(localConfigurators);
        List<Configurator> localAppDynamicConfigurators = CONSUMER_CONFIGURATION_LISTENER.getConfigurators(); // local reference
        doOverrideUrl(localAppDynamicConfigurators);
        if (serviceConfigurationListener != null) {
            List<Configurator> localDynamicConfigurators = serviceConfigurationListener.getConfigurators(); // local reference
            doOverrideUrl(localDynamicConfigurators);
        }
    }


```




## 三、负载均衡（Load Balance)

## 四、容错（Fault-Tolerant）

## 五、路由（Route)

## 六、总结



